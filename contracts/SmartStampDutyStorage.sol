pragma solidity ^0.4.24;

import "./Ownable.sol";
import "./IERC20.sol";

/**
 * @title SmartStampDutyStorage
 * @dev A new class for stamp duty called StampDuty
 * @dev 
 */
contract SmartStampDutyStorage is Ownable {
    /**
    * @dev changeToken 
    * @param changeToken
    */
    IERC20 token;
    function changeToken(IERC20 newToken) onlyOwner public {
        token = newToken;
    }
        
    /**
    * @dev zeroAddress can be used to burn tokens that have been received and audited.
    * @param zeroAddress is unusable
    */    
    address constant public zeroAddress = 0x0000000000000000000000000000000000000000;
    
    /**
    * @dev Referential Integrity check https://medium.com/@robhitchens/enforcing-referential-integrity-in-ethereum-smart-contracts-a9ab1427ff42
    * @dev StampParam contains system parameters
    * @dev StampParam can only be modified by owner
    * @param StampCode is the unique code for the stamp and the primary key.
    * @param StampName is the name of the stamp in human readable format
    * @param StampPrice is the price of the stamp, in integer
    * @param RegulationReference is the reference to a specific tax regulation
    * @param StampIndex is the index or position of the data
    */  
    struct StampParam {
        bytes32 StampCode;
        string StampName;
        uint32 StampPrice;
        string RegulationReference;
        uint StampIndex;
        bool IsActive;
        /**
         * @dev To support deletion and keeps the referential integrity
         * @param PayParamDocHash is to refer to Document hash
         * @param PayIndexPointers refers to the payment details
        */
        bytes32[] PayCode;
        mapping (bytes32 => uint256) PayIndexPointers;
    }
    /**
     * @param StampStructs is for indexing based on StampName
     * @param StampList is for sequential access based on StampCode to get the stamp row data
    */
    mapping (bytes32 => StampParam) StampStructs;
    bytes32[] StampList;
    
    /**
    * @dev PayParam is to store payment detail
    * @param PayCode is the payment code generated by the system. It can be a hash of document hash, payer address, and timestamp. This is the primary key and unique.
    * @param DocHash is the hash value of the document. DocHash is not unique.
    * @param PayIndex is the index of the payment
    * @param Payer is the address of the Payer
    * @param StampIndex refers to the StampParam
    * @param BloomFilter is used to test the similarity between the original document (hashed one) and the claimed document (printed or electronic document)
    */ 
    struct PayParam {
        bytes32 PayCode;
        string DocHash;
        uint256 PayIndex;
        address Payer;
        bytes32 StampCode;
        string BloomFilter;
    }
    
    mapping (bytes32 => PayParam) PayStructs;
    bytes32[] PayList;
    
    /**
     * @dev getStampCount counts the number of stamp types
     */
    function getStampCount() public constant returns (uint stampCount) {
        return StampList.length;
    }
    
    /**
     * @dev getStampList returns StampList
     */
    function getStampList() public constant returns (bytes32[]) {
        return StampList;
    }
    
    /**
     * @dev getStampPayCodes returns PayCode array
     * @dev can be used to list all payments of a stamp, determined by stampCode
     */
    function getStampPayCodes(bytes32 stampCode) public constant returns (bytes32[]) {
        return StampStructs[stampCode].PayCode;
    }
    
    /**
     * @dev getStampDetail gets the detail of stamp data based on StampCode
     * @dev reference: https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
     * @dev returns the structure of StampParam
     */
    function getStampDetail(bytes32 stampCode) public constant returns (bytes32 StampCode, string StampName, uint32 StampPrice, 
        string RegulationReference, uint StampIndex, bool isActive) {
        StampParam memory s = StampStructs[stampCode];
        return (s.StampCode, s.StampName, s.StampPrice, s.RegulationReference, s.StampIndex, s.IsActive);
    }
    
    /**
     * @dev getStampDetailByIndex gets the detail of stamp data based on its index
     * @dev reference: https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
     * @dev returns the structure of StampParam
     */
    function getStampDetailByIndex(uint stampIndex) public constant returns (bytes32 StampCode, string StampName, uint32 StampPrice, 
        string RegulationReference, uint StampIndex, bool isActive) {
        // get the StampCode first
        bytes32 stampCode = StampList[stampIndex];
        StampParam memory s = StampStructs[stampCode];
        return (s.StampCode, s.StampName, s.StampPrice, s.RegulationReference, s.StampIndex, s.IsActive);
    }
    
    /**
     * @dev stampActivate activates the stamp described by stampCode
     * @dev onlyOwner
     */
    function stampActivate(bytes32 stampCode) public onlyOwner returns (bool success) {
        // check if it is a valid stamp
        require(isStamp(stampCode));
        // check if stamp is currently deactivated
        require(StampStructs[stampCode].IsActive == false);
        StampStructs[stampCode].IsActive = true;
        return true;
    }
    
    /**
     * @dev stampDeactivate deactivates the stamp described by stampCode
     * @dev onlyOwner
     */
    function stampDeactivate(bytes32 stampCode) public onlyOwner returns (bool success) {
        // check if it is a valid stamp
        require(isStamp(stampCode));
        // check if stamp is currently activated
        require(StampStructs[stampCode].IsActive == true);
        StampStructs[stampCode].IsActive = false;
        return true;
    }
    
    /**
     * @dev getPaymentCount counts the number of payments
     */
    function getPaymentCount() public constant returns (uint paymentCount) {
        return PayList.length;
    }
    
    /**
     * @dev getPayList returns PayList array
     */
    function getPayList() public constant returns (bytes32[]) {
        return PayList;
    }
    
    /**
     * @dev getPaymentDetail gets the detail of payment data based on PayCode
     * @dev reference: https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378
     * @dev returns the structure of PayParam
     */
    function getPaymentDetail(bytes32 payCode) public constant returns (bytes32 PayCode, string DocHash, uint256 PayIndex, 
        address Payer, bytes32 StampCode, string BloomFilter) {
        PayParam memory p = PayStructs[payCode];
        return (p.PayCode, p.DocHash, p.PayIndex, p.Payer, p.StampCode, p.BloomFilter);
    }
    
    /**
     * @dev isStamp checks if the stamp is valid
     */
    function isStamp (bytes32 stampCode) public constant returns (bool isIndeed) {
        if (StampList.length == 0) return false;
        return StampList[StampStructs[stampCode].StampIndex] == stampCode;
    }
    
    /**
     * @dev isPayment checks if a particular payment code exists
     */
    function isPayment (bytes32 payCode) public constant returns (bool isIndeed) {
        if (PayList.length == 0) return false;
        return PayList[PayStructs[payCode].PayIndex] == payCode;
    }
    
    /**
     * @dev getPaymentOfStampCount counts payments based on a specific StampName
     */
    function getPaymentOfStampCount(bytes32 stampCode) public constant returns (uint paymentOfStampCount) {
        //deprecated if(!isStamp(StampName)) throw;
        require(isStamp(stampCode));
        return StampStructs[stampCode].PayCode.length;
    }
    
    /**
     * @dev getPaymentOfStampAtIndex payments based on a specific StampName
     */
    function getPaymentOfStampAtIndex(bytes32 stampCode, uint row) public constant returns (bytes32 paymentCode) {
        require(isStamp(stampCode));
        return StampStructs[stampCode].PayCode[row];
    }
    
    /**
     * @dev createStamp creates a new stamp, only owner can do this
     */
    function createStamp(bytes32 stampCode, string stampName, uint32 stampPrice, string regulationReference, bool isActive) public onlyOwner returns (bool success) {
        //prevent duplicate
        require(!isStamp(stampCode));
        //add new data
        /**
        bytes32 StampCode;
        string StampName;
        uint32 StampPrice;
        string RegulationReference;
        uint StampIndex;
         */
        StampStructs[stampCode].StampCode = stampCode;
        StampStructs[stampCode].StampName = stampName;
        StampStructs[stampCode].StampPrice = stampPrice;
        StampStructs[stampCode].RegulationReference = regulationReference;
        StampStructs[stampCode].StampIndex = StampList.push(stampCode) - 1;
        StampStructs[stampCode].IsActive = isActive;
        
        /**
         * @Todo should add Event here
         */
        return true;
    }
    
    /**
     * @dev createPayment creates a new payment
     */
    function createPayment(bytes32 payCode, string docHash, bytes32 stampCode, string bloomFilter) public returns (bool success) {
        //prevent duplicate
        require(!isPayment(payCode));
        //check referential integrity for stampCode
        require(isStamp(stampCode));
        //stamp needs to be active
        require(StampStructs[stampCode].IsActive == true);
        //check payCode cannot empty
        require(payCode.length > 0);
        //check dochHash cannot empty
        bytes memory tempDocHash = bytes(docHash);
        require(tempDocHash.length > 0);
        //require the balance to be enough to pay the stamp price
        require(token.balanceOf(msg.sender) >= StampStructs[stampCode].StampPrice);
        //pay the stamp duty to the smart contract owner
        token.transfer(owner(), StampStructs[stampCode].StampPrice);

        /**
        bytes32 PayCode;
        string DocHash;
        uint256 PayIndex;
        address Payer;
        bytes32 StampCode;
        string BloomFilter;
         */
        PayStructs[payCode].PayCode = payCode;
        PayStructs[payCode].DocHash = docHash;
        PayStructs[payCode].PayIndex = PayList.push(payCode) - 1;
        PayStructs[payCode].Payer = msg.sender;
        PayStructs[payCode].StampCode = stampCode;
        PayStructs[payCode].BloomFilter = bloomFilter;
        
        //maintain new payment in Stamp data
        StampStructs[stampCode].PayIndexPointers[payCode] = StampStructs[stampCode].PayCode.push(payCode) - 1;
        /**
         * @Todo should add Event here
         */
        return true;
    }
    
    /**
     * @Todo create functions to modify and delete stamp
     * @Todo modify and delete payment might not be needed
     */
    
    
    /**
     * @dev A function to burn tokens to constant address zeroAddress.
     */
    function _burnToZeroAddress(uint256 value) public onlyOwner returns (bool) {
    token.transfer(zeroAddress, value);
    return true;
  }  
}
